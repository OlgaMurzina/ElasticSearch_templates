Данная сборка предназначена для изучения API Elasticsearch

# API Elasticsearch.py
## class elasticsearch.Elasticsearch
### Атрибуты класса:

* hosts=None,
* transport_class=<class 'elasticsearch.transport.Transport'>,
* **kwargs)  

https://elasticsearch-py.readthedocs.io/en/master/api.html#elasticsearch  

Низкоуровневый клиент Elasticsearch. Обеспечивает прямое сопоставление Python с конечными точками ES REST.  

### Mетоды класса:

#### count(body=None, index=None, params=None, headers=None) - метод возвращеает количество документов в индексе согласно запросу -> int
* body – запрос, написанный на Query DSL (необязательная опция)
* index – список индексов, разделенных запятыми, для ограничения результатов
* analyze_wildcard – указание, следует ли анализировать запросы с подстановочными знаками и префиксами (по умолчанию: false)
* analyzer – анализатор строки запроса
* default_operator – оператор по умолчанию для строки запросов (И или ИЛИ), значение по умолчанию: ИЛИ
* df – поле, используемое по умолчанию, если в строке запроса не указан префикс поля
* expand_wildcards – расширять ли выражение с подстановочными знаками до конкретных индексов, которые open, closed или both (по умолчанию: open)
* ignore_unavailable – должны ли указанные конкретные индексы игнорироваться, когда они недоступны (отсутствуют или закрыты)
* lenient – следует ли игнорировать ошибки запроса на основе формата (например, ввод текста в числовое поле)
* min_score – включать в результат только документы с определенным значением _score
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* q – запрос в синтаксисе строки запроса Lucene
* terminate_after – максимальное количество для каждого шарда, при достижении которого выполнение запроса будет прекращено досрочно  

#### create(index, id, body, doc_type=None, params=None, headers=None) - метод создает новый документ в индексе. Возвращает ответ 409, когда документ с таким же идентификатором уже существует в индексе
* index – имя индекса
* id – ID документа 
* body – документ
* pipeline – идентификатор конвейера для предварительной обработки входящих документов
* refresh – true - обновите затронутые сегменты, чтобы сделать эту операцию видимой для поиска; wait_for - дождитесь обновления, чтобы сделать эту операцию видимой для поиска; false (по умолчанию) - ничего не делайте с обновлениями
* routing – конкретное значение маршрутизации
* timeout – явный тайм-аут операции
* version – явный номер версии для управления параллелизмом
* version_type – конкретный тип версии: internal, external, external_gte
* wait_for_active_shards – устанавливает количество копий сегментов, которые должны быть активны перед продолжением операции с индексом, по умолчанию 1, что означает только основной сегмент. Установите значение all для всех копий сегмента, в противном случае установите любое неотрицательное значение, меньшее или равное общему количеству копий сегмента (количество реплик + 1)

#### delete(index, id, doc_type=None, params=None, headers=None) - метод удаляет документ из индекса
* index – имя индекса
* id – ID документа 
* if_primary_term – выполнять операцию удаления только в том случае, если последняя операция, которая изменила документ, имеет указанный первичный термин
* if_seq_no – выполнять операцию удаления только в том случае, если последняя операция, которая изменила документ, имеет указанный порядковый номер
* refresh – true - обновите затронутые сегменты, чтобы сделать эту операцию видимой для поиска; wait_for - дождитесь обновления, чтобы сделать эту операцию видимой для поиска; false (по умолчанию) - ничего не делайте с обновлениями
* routing – конкретное значение маршрутизации
* timeout – явный тайм-аут операции
* version – явный номер версии для управления параллелизмом
* version_type – конкретный тип версии: internal, external, external_gte
* wait_for_active_shards – устанавливает количество копий сегментов, которые должны быть активны перед продолжением операции с индексом, по умолчанию 1, что означает только основной сегмент. Установите значение all для всех копий сегмента, в противном случае установите любое неотрицательное значение, меньшее или равное общему количеству копий сегмента (количество реплик + 1)

#### delete_by_query(index, body, params=None, headers=None) - метод удаляет документы, соответствующие заданному запросу
* index – разделенный запятыми список имен индексов для поиска; используйте _all или пустую строку для выполнения операции со всеми индексами
* body – запрос, написанный на Query DSL 
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* analyze_wildcard – указание, следует ли анализировать запросы с подстановочными знаками и префиксами (по умолчанию: false)
* analyzer – анализатор строки запроса
* conflicts – что делать, если удаление по запросу сталкивается с конфликтами версий? Возможные варианты: прервать, продолжить. По умолчанию: прервать
* default_operator – оператор по умолчанию для строки запросов (И или ИЛИ) (по умолчанию: ИЛИ)
* df – поле, используемое по умолчанию, если в строке запроса не указан префикс поля
* expand_wildcards – расширять ли выражение с подстановочными знаками до конкретных индексов, которые open, closed или both (по умолчанию: open)
* from_ – начальное смещение (по умолчанию: 0)
* ignore_unavailable – должны ли указанные конкретные индексы игнорироваться, когда они недоступны (отсутствуют или закрыты)
* lenient – следует ли игнорировать ошибки запроса на основе формата (например, ввод текста в числовое поле)
* max_docs – максимальное количество документов для обработки (по умолчанию: все документы)
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* q – запрос в синтаксисе строки запроса Lucene
* refresh – следует ли обновить затронутые индексы?
* request_cache – укажите, следует ли использовать кеш запроса для этого запроса или нет (по умолчанию используется настройка уровня индекса)
* routing – разделенный запятыми список определенных значений маршрутизации
* scroll – укажите, как долго должно поддерживаться согласованное представление индекса для поиска с прокруткой
* scroll_size – размер в запросе на прокрутку, обеспечивающий удаление по запросу (по умолчанию: 100)
* search_timeout – тайм-аут для каждого поискового запроса (по умолчанию: нет тайм-аута)
* search_type – тип операции поиска Допустимые варианты: query_then_fetch, dfs_query_then_fetch
* slices – количество срезов, на которые нужно разделить эту задачу (по умолчанию: 1 - это означает, что задача не разделена на подзадачи, можно поставить auto)
* sort – разделенный запятыми список пар <field>:<direction>
* stats – конкретный «тег» запроса для регистрации и статистических целей
* terminate_after – максимальное количество для каждого шарда, при достижении которого выполнение запроса будет прекращено досрочно
* timeout – время, в течение которого каждый отдельный массовый запрос должен ждать недоступных сегментов (по умолчанию: 1 м)
* version – укажите, следует ли возвращать версию документа как часть обращения
* wait_for_active_shards – устанавливает количество копий сегментов, которые должны быть активны перед продолжением операции с индексом, по умолчанию 1, что означает только основной сегмент. Установите значение all для всех копий сегмента, в противном случае установите любое неотрицательное значение, меньшее или равное общему количеству копий сегмента (количество реплик + 1)
* wait_for_completion – должен ли запрос блокироваться до завершения удаления по запросу (по умолчанию: true)
  
#### exists(index, id, params=None, headers=None) - метод возвращает информацию о том, существует ли документ в индексе	-> True/False
* index – имя индекса
* id – ID документа
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* realtime – укажите, следует ли выполнять операцию в режиме реального времени или в режиме поиска
* refresh – обновить шард, содержащий документ, перед выполнением операции
* routing – конкретное значение маршрутизации
* stored_fields – разделенный запятыми список сохраненных полей для возврата в ответе
* version – явный номер версии для управления параллелизмом
* version_type – конкретный тип версии: internal, external, external_gte

#### exists_source(index, id, doc_type=None, params=None, headers=None) - метод возвращает информацию о том, существует ли источник документа в индексе	-> True/False
* index – имя индекса
* id – ID документа
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* realtime – укажите, следует ли выполнять операцию в режиме реального времени или в режиме поиска
* refresh – обновить шард, содержащий документ, перед выполнением операции
* routing – конкретное значение маршрутизации
* version – явный номер версии для управления параллелизмом
* version_type – конкретный тип версии: internal, external, external_gte

#### field_caps(body=None, index=None, params=None, headers=None) - метод возвращает информацию о “типах” одних и тех же полей в нескольких индексах -> json
* body – запрос, написанный на Query DSL
* index - разделенный запятыми список имен индексов для поиска; используйте _all или пустую строку для выполнения операции со всеми индексами
* expand_wildcards – расширять ли выражение с подстановочными знаками до конкретных индексов, которые open, closed или both (по умолчанию: open)
* fields – разделенный запятыми список имен полей для сопоставления
* ignore_unavailable – должны ли указанные конкретные индексы игнорироваться, когда они недоступны (отсутствуют или закрыты)
* include_unmapped – указывает, следует ли включать в ответ несопоставленные поля

#### get(index, id, params=None, headers=None) - метод возвращает документ по  его ID	-> json
* index – имя индекса
* id – ID документа
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* realtime – укажите, следует ли выполнять операцию в режиме реального времени или в режиме поиска
* refresh – обновить шард, содержащий документ, перед выполнением операции
* routing – конкретное значение маршрутизации
* stored_fields – разделенный запятыми список сохраненных полей для возврата в ответе
* version – явный номер версии для управления параллелизмом
* version_type – конкретный тип версии: internal, external, external_gte

#### get_source(index, id, params=None, headers=None) - метод возвращает источник документа -> json
* index – имя индекса
* id – ID документа
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* realtime – укажите, следует ли выполнять операцию в режиме реального времени или в режиме поиска
* refresh – обновить шард, содержащий документ, перед выполнением операции
* routing – конкретное значение маршрутизации
* version – явный номер версии для управления параллелизмом
* version_type – конкретный тип версии: internal, external, external_gte

#### index(index, body, id=None, params=None, headers=None) - метод создает или обновляет документ в индексе
* index – имя индекса
* body – документ
* id – ID документа
* if_primary_term – выполнять операцию индексирования только в том случае, если последняя операция, которая изменила документ, имеет указанный первичный термин
* if_seq_no – выполнять операцию индексирования только в том случае, если последняя операция, которая изменила документ, имеет указанный порядковый номер
* op_type – по умолчанию индексируется для запросов с явным идентификатором документа и “создается” для запросов без явного идентификатора документа. Допустимые варианты: index, create
* pipeline – идентификатор конвейера для предварительной обработки входящих документов
* refresh – true - обновите затронутые сегменты, чтобы сделать эту операцию видимой для поиска; wait_for - дождитесь обновления, чтобы сделать эту операцию видимой для поиска; false (по умолчанию) - ничего не делайте с обновлениями
* require_alias – при значении true требуется, чтобы пункт назначения был псевдонимом (значение по умолчанию — false)
* routing – конкретное значение маршрутизации
* timeout – тайм-аут операции
* version – номер версии для управления параллелизмом
* version_type – конкретный тип версии: internal, external, external_gte
* wait_for_active_shards – устанавливает количество копий сегментов, которые должны быть активны перед продолжением операции с индексом, по умолчанию 1, что означает только основной сегмент. Установите значение all для всех копий сегмента, в противном случае установите любое неотрицательное значение, меньшее или равное общему количеству копий сегмента (количество реплик + 1)

#### info(params=None, headers=None) -	метод возвращает основную информацию о кластере	-> json

#### mget(body, index=None, params=None, headers=None) - метод позволяет получить несколько документов одним запросом	-> json
* body – идентификаторы документов; может быть либо docs (содержащим полную информацию о документе), либо id (когда index указан в URL-адресе)
* index – имя индекса
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* realtime – укажите, следует ли выполнять операцию в режиме реального времени или в режиме поиска
* refresh – обновить шард, содержащий документ, перед выполнением операции
* routing – конкретное значение маршрутизации
* stored_fields – разделенный запятыми список сохраненных полей для возврата в ответе

#### msearch(body, index=None, params=None, headers=None) - метод позволяет выполнять несколько поисковых операций в одном запросе	-> json
* body – несколько запросов, разделенных символом новой строки
* index – список имен индексов, разделенных запятыми
* ccs_minimize_roundtrips – указывает, должны ли быть сведены к минимуму сетевые обращения как часть выполнения межкластерных поисковых запросов (по умолчанию: true)
* max_concurrent_searches – управляет максимальным количеством одновременных поисков, которые будет выполнять API множественного поиска
* max_concurrent_shard_requests – количество одновременных запросов сегментов, в которых каждый подпоиск выполняется одновременно на узле. Это значение следует использовать для ограничения влияния поиска на кластер, чтобы ограничить количество одновременных запросов на сегменты (по умолчанию: 5)
* pre_filter_shard_size – пороговое значение, которое применяет предварительную фильтрацию туда и обратно для предварительной фильтрации сегментов поиска на основе перезаписи запроса, если количество сегментов, до которых расширяется поисковый запрос, превышает пороговое значение. Этот фильтр может значительно ограничить количество сегментов, если, например, сегмент не может соответствовать ни одному документу на основе его метода перезаписи, т.е. если фильтры даты обязательны для соответствия, но границы сегмента и запрос не пересекаются
* rest_total_hits_as_int – указывает, следует ли отображать hits.total как целое число или как объект в оставшемся ответе на поиск
* search_type – тип операции поиска - допустимые варианты: query_then_fetch, dfs_query_then_fetch
* typed_keys – укажите, должны ли имена агрегации и подсказки предваряться их соответствующими типами в ответе

#### open_point_in_time(index=None, params=None, headers=None) - метод открывает момент времени, который можно использовать в последующих поисках	??? исследовать, что возвращает
* index – список имен индексов, разделенных запятыми, для открытия на определенный момент времени; используйте _all или пустую строку для выполнения операции со всеми индексами
* expand_wildcards – расширять ли выражение с подстановочными знаками до конкретных индексов, которые open, closed или both (по умолчанию: open)
* ignore_unavailable – должны ли указанные конкретные индексы игнорироваться, когда они недоступны (отсутствуют или закрыты)
* keep_alive – конкретное время жизни на момент времени
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* routing – конкретное значение маршрутизации

#### rank_eval(body, index=None, params=None, headers=None) - метод позволяет оценить качество ранжированных результатов поиска по набору типичных поисковых запросов	Возвращает типичные метрики поиска информации, такие как средний взаимный ранг, точность или дисконтированный кумулятивный выигрыш -> json
* body – определение поиска оценки ранжирования, включая поисковые запросы, рейтинги документов и определение метрики ранжирования
* index – список имен индексов, разделенных запятыми; используйте _all или пустую строку для выполнения операции со всеми индексами
* allow_no_indices – следует ли игнорировать, если выражение индексов с подстановочными знаками не разрешается в конкретные индексы (это включает строку _all или когда индексы не указаны)
* expand_wildcards – расширять ли выражение с подстановочными знаками до конкретных индексов, которые open, closed или both (по умолчанию: open)
* ignore_unavailable – должны ли указанные конкретные индексы игнорироваться, когда они недоступны (отсутствуют или закрыты)
* search_type – тип операции поиска - допустимые варианты: query_then_fetch, dfs_query_then_fetch

#### reindex(body, params=None, headers=None) - метод позволяет копировать документы из одного индекса в другой, дополнительно фильтруя исходные документы по запросу, изменяя настройки целевого индекса или извлекая документы из удаленного кластера
* body – определение поиска с использованием Query DSL и прототипа запроса индекса
* max_docs – максимальное количество документов для обработки (по умолчанию: все документы)
* refresh – следует ли обновить затронутые индексы?
* requests_per_second – подзапросов в секунду (-1 - не учитывать этот параметр)
* scroll – время, как долго должен поддерживаться поиск (по умолчанию: 5 м)
* slices – количество срезов, на которые нужно разделить эту задачу (по умолчанию 1, что означает, что задача не разделена на подзадачи). Можно установить на auto
* timeout – время, в течение которого каждый отдельный массовый запрос должен ждать недоступных сегментов (по умолчанию: 1 м)
* wait_for_active_shards – устанавливает количество копий сегментов, которые должны быть активны перед продолжением операции с индексом, по умолчанию 1, что означает только основной сегмент. Установите значение all для всех копий сегмента, в противном случае установите любое неотрицательное значение, меньшее или равное общему количеству копий сегмента (количество реплик + 1)
* wait_for_completion – должен ли запрос блокироваться до завершения удаления по запросу (по умолчанию: true)

#### scroll(body=None, scroll_id=None, params=None, headers=None) - метод позволяет делать скролл поиска по scroll_id при больших кол-вах документов в индексе	-> json
* body – поисковый запрос  с использованием Query DSL
* scroll_id – идентификатор прокрутки для поиска с прокруткой
* rest_total_hits_as_int – указывает, следует ли отображать hits.total как целое число или как объект в оставшемся ответе на поиск
* scroll – время ожидания для поиска с прокруткой

#### search(body=None, index=None, params=None, headers=None) - метод возвращает результаты, соответствующие запросу	-> json
* body – поисковый запрос  с использованием Query DSL
* index – список имен индексов, разделенных запятыми; используйте _all или пустую строку для выполнения операции со всеми индексами
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* allow_no_indices – cледует ли игнорировать, если выражение индексов с подстановочными знаками не разрешается в конкретные индексы (это включает строку _all или когда индексы не указаны)
* allow_partial_search_results – укажите, должна ли возвращаться ошибка при частичном сбое поиска или тайм-ауте  (по умолчанию: True)
* analyze_wildcard – укажите, следует ли анализировать запросы с подстановочными знаками и префиксами (по умолчанию: False)
* analyzer – анализатор для строки запроса
* batched_reduce_size – количество шард-результатов, которое нужно сразу уменьшить на координирующем узле. Это значение следует использовать в качестве защитного механизма, чтобы уменьшить накладные расходы памяти на поисковый запрос, если потенциальное количество шард в запросе может быть большим (по умолчанию: 512)
* ccs_minimize_roundtrips – указывает, должны ли быть сведены к минимуму сетевые обращения как часть выполнения межкластерных поисковых запросов (по умолчанию: True)
* default_operator – оператор по умолчанию для строк запросов (И или ИЛИ) (значение по умолчанию: ИЛИ)
* df – поле, используемое по умолчанию, если в строке запроса не указан префикс поля
* docvalue_fields – список полей, разделенных запятыми, которые должны возвращаться в качестве представления docvalue поля для каждого обращения
* expand_wildcards – расширять ли выражение с подстановочными знаками до конкретных индексов, которые open, closed или both (по умолчанию: open)
* explain – укажите, следует ли возвращать подробную информацию о вычислении оценки как часть обращения
* from_ – начальное смещение (по умолчанию: 0)
* ignore_throttled – должны ли указанные конкретные, расширенные или псевдонимные индексы игнорироваться при throttle
* ignore_unavailable – должны ли указанные конкретные индексы игнорироваться, когда они недоступны (отсутствуют или закрыты)
* lenient – укажите, следует ли игнорировать ошибки запроса на основе формата (например, ввод текста в числовое поле)
* max_concurrent_shard_requests – количество одновременных запросов сегментов на сегмент, которые этот поиск выполняет одновременно. Это значение следует использовать для ограничения влияния поиска на кластер, чтобы ограничить количество одновременных запросов сегментов (по умолчанию: 5)
* min_compatible_shard_node – минимальная совместимая версия, которая должна быть у всех сегментов, участвующих в поиске, чтобы этот запрос был успешным
* pre_filter_shard_size – пороговое значение, которое применяет предварительную фильтрацию туда и обратно для предварительной фильтрации сегментов поиска на основе перезаписи запроса, если количество сегментов, до которых расширяется поисковый запрос, превышает пороговое значение. Этот фильтр может значительно ограничить количество сегментов, если, например, сегмент не может соответствовать ни одному документу на основе его метода перезаписи, т.е. если фильтры даты обязательны для соответствия, но границы сегмента и запрос не пересекаются
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* q – запрос в синтаксисе строки запроса Lucene
* request_cache – укажите, следует ли использовать кеш запроса для этого запроса или нет (по умолчанию используется настройка уровня индекса)
* rest_total_hits_as_int – указывает, следует ли отображать hits.total как целое число или как объект в оставшемся ответе на поиск
* routing – разделенный запятыми список определенных значений маршрутизации
* scroll – время ожидания ответа индекса для поиска с прокруткой
* search_type – тип операции поиска; допустимые варианты: query_then_fetch, dfs_query_then_fetch
* seq_no_primary_term – укажите, следует ли возвращать порядковый номер и основной термин последней модификации каждого попадания
* size – количество возвращаемых обращений (по умолчанию: 10)
* sort – разделенный запятыми список пар <field>:<direction>
* stats – конкретный «тег» запроса для регистрации и статистических целей
* stored_fields – разделенный запятыми список сохраненных полей для возврата в ответе
* suggest_field – укажите, какое поле использовать для предложений
* suggest_mode – укажите режим предложения; допустимые варианты: missing, popular, always (по умолчанию : missing)
* suggest_size – сколько предложений вернуть в ответ
* suggest_text – исходный текст, для которого должны быть возвращены предложения
* terminate_after – максимальное количество документов для сбора для каждого шарда, при достижении которого выполнение запроса будет прекращено досрочно
* timeout – тайм-аут операции
* track_scores – следует ли рассчитывать и возвращать баллы, даже если они не используются для сортировки
* track_total_hits – укажите, следует ли отслеживать количество документов, соответствующих запросу. Также можно указать число, чтобы точно отслеживать общее количество попаданий до числа
* typed_keys – укажите, должны ли имена агрегации и подсказки предваряться их соответствующими типами в ответе
* version – укажите, следует ли возвращать версию документа как часть обращения

#### termvectors(index, body=None, id=None, params=None, headers=None) - метод возвращает информацию и статистику о терминах в полях конкретного документа	-> json
* index – индекс, в котором находится документ
* body – определите параметры и/или предоставьте документ, для которого нужно получить термвекторы. См. документацию.
* id – идентификатор документа, если не указан параметр документа, должен быть указан
* field_statistics – указывает, следует ли возвращать количество документов, сумму частот документов и сумму общих частот терминов (по умолчанию: True)
* fields – разделенный запятыми список возвращаемых полей
* offsets – указывает, следует ли возвращать смещения терминов (по умолчанию: True)
* payloads – указывает, следует ли возвращать полезные данные термина (по умолчанию: True)
* positions – указывает, следует ли возвращать позиции терминов (по умолчанию: True)
* preference – укажите узел или сегмент, на котором должна выполняться операция (по умолчанию: случайный)
* realtime – указывает, выполняется ли запрос в режиме реального времени, а не в режиме, близком к реальному времени (по умолчанию: True)
* routing – конкретное значение маршрутизации
* term_statistics – указывает, следует ли возвращать общую частоту терминов и частоту документов
* version – номер версии для управления параллелизмом
* version_type – тип версии, допустимые варианты: internal, external, external_gte

#### update(index, id, body, doc_type=None, params=None, headers=None) - метод выполняет обновление для каждого документа в индексе без изменения источника, например, для получения изменения сопоставления
* index – список имен индексов, разделенных запятыми; используйте _all или пустую строку для выполнения операции со всеми индексами
* body – поисковый запрос  с использованием Query DSL
* _source – true или false, чтобы вернуть поле _source или нет, или список полей, которые нужно вернуть
* _source_excludes – cписок полей, которые следует исключить из возвращаемого поля _source
* _source_includes – cписок полей для извлечения и возврата из поля _source
* allow_no_indices – cледует ли игнорировать, если выражение индексов с подстановочными знаками не разрешается в конкретные индексы (это включает строку _all или когда индексы не указаны)
* analyze_wildcard – указание, следует ли анализировать запросы с подстановочными знаками и префиксами (по умолчанию: false)
* analyzer – анализатор строки запроса
* conflicts – что делать, если удаление по запросу сталкивается с конфликтами версий? Возможные варианты: прервать, продолжить. По умолчанию: прервать
* default_operator – оператор по умолчанию для строк запросов (И или ИЛИ) (значение по умолчанию: ИЛИ)
* df – поле, используемое по умолчанию, если в строке запроса не указан префикс поля
* expand_wildcards – расширять ли выражение с подстановочными знаками до конкретных индексов, которые open, closed или both (по умолчанию: open)
* from_ – начальное смещение (по умолчанию: 0)
* ignore_unavailable – должны ли указанные конкретные индексы игнорироваться, когда они недоступны (отсутствуют или закрыты)
* lenient – следует ли игнорировать ошибки запроса на основе формата (например, ввод текста в числовое поле)
* max_docs – максимальное количество документов для обработки (по умолчанию: все документы)
* pipeline – идентификатор конвейера для предварительной обработки входящих документов (по умолчанию None)
* preference – укажите узел или сегмент, на котором должна быть выполнена операция (по умолчанию: случайный)
* q – запрос в синтаксисе строки запроса Lucene
* refresh – следует ли обновить затронутые индексы?
* request_cache – укажите, следует ли использовать кеш запроса для этого запроса или нет (по умолчанию используется настройка уровня индекса)
* requests_per_second – подзапросов в секунду (-1 - не учитывать этот параметр)
* routing – разделенный запятыми список определенных значений маршрутизации
* scroll – время ожидания ответа индекса для поиска с прокруткой
* scroll_size – размер в запросе на прокрутку, обеспечивающий удаление по запросу (по умолчанию: 100)
* search_timeout – тайм-аут для каждого поискового запроса (по умолчанию: нет тайм-аута)
* search_type – тип операции поиска; допустимые варианты: query_then_fetch, dfs_query_then_fetch
* slices – количество срезов, на которые нужно разделить эту задачу (по умолчанию 1, что означает, что задача не разделена на подзадачи). Можно установить на auto
* sort –  разделенный запятыми список пар <field>:<direction>
* stats – конкретный «тег» запроса для регистрации и статистических целей
* terminate_after – максимальное количество документов для сбора для каждого шарда, при достижении которого выполнение запроса будет прекращено досрочно
* timeout – время, в течение которого каждый отдельный массовый запрос должен ждать недоступных сегментов (по умолчанию: 1 м)
* version – eкажите, следует ли возвращать версию документа как часть обращения
* version_type – должен ли документ увеличивать номер версии (внутренний) при попадании или нет (переиндексировать)
* wait_for_active_shards – устанавливает количество копий сегментов, которые должны быть активны перед продолжением операции с индексом, по умолчанию 1, что означает только основной сегмент. Установите значение all для всех копий сегмента, в противном случае установите любое неотрицательное значение, меньшее или равное общему количеству копий сегмента (количество реплик + 1)
* wait_for_completion – должен ли запрос блокироваться до завершения удаления по запросу (по умолчанию: true)
